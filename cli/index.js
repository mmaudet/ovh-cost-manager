#!/usr/bin/env node

// appKey + appSecret are generated by https://eu.api.ovh.com/createToken/
// export AK=appKey
// curl -H "Content-type: application/json" -H "X-Ovh-Application: $AK" -d '{"accessRules": [{"method": "GET", "path": "/me/*"}]}' https://eu.api.ovh.com/1.0/auth/credential
// the credential query return consumerKey

const Path = require('path');
const Fs = require('fs');
const https = require('https');
const Jsonfile = require('jsonfile');
const { exit } = require('process');
const argv = require('minimist')(process.argv.slice(2)) || {};

// Concurrency limit for parallel downloads (respects OVH API rate limits)
const CONCURRENT_DOWNLOADS = 5;
const APP_DATA = Path.resolve(process.env.HOME, "my-ovh-bills");
const HIST_FILE = Path.resolve(APP_DATA, ".history.json");
const YEAR = new Date().getUTCFullYear().toString();
let OUTPUT = Path.resolve(APP_DATA, YEAR);
let HISTORY = [];
let OPTIONS = {};
if (!Fs.existsSync(OUTPUT)) {
  Fs.mkdirSync(OUTPUT, { recursive: true });
}

/**
 * Returns today's date in ISO format (YYYY-MM-DD)
 * @returns {string} Today's date in YYYY-MM-DD format
 */
function today() {
  return new Date().toISOString().split('T')[0];
}


/**
 * 
 */
function help() {
  console.log(`--help -> show this message)`);
}

/**
 * 
 */
function usage(to, quit = 0) {
  console.log(`--from=YYYY-MM-DD -> Mandatory, start of billing period date`);
  console.log(`--to=YYYY-MM-DD -> Optional, end of billing period date, defaulted to today (${today()})`);
  console.log(`--output=/path/to/bill-files -> Optional, directory where to store bills, defaulted to $HOME/my-ovh-bills`);
  console.log(`--format=pdf|html -> Optional, bill format, defaulted to pdf`);
  console.log(`--summary -> Generate markdown summary instead of downloading files`);
  console.log(`--json -> Save bill metadata as JSON files`);
  console.log(`--verbose -> Show bill metadata in console`);
  if (quit) exit(1);
}

/**
 * 
 */
function tip() {
  let a = '{"accessRules": [{"method": "GET", "path": "/me/*"}]}';
  console.log("==========================================================================");
  console.log("To generate credentials :");
  console.log("  1/ Generate appKey + appSecret from https://eu.api.ovh.com/createToken/:");
  console.log("  2/ Then run this command on your shell: :");
  console.log("export AK=appKey");
  console.log(`curl -H "Content-type: application/json" -H "X-Ovh-Application: $AK" -d '${a}' https://eu.api.ovh.com/1.0/auth/credential`);
  console.log("Then use returned values to fill in all the fields in the file credentials.json");
  console.log("==========================================================================");
  exit(1);
}


if (argv.help) {
  help();
  usage();
  tip();
}


/** */
function getBillsUrl() {
  let to = today(); // Use consistent ISO date format
  let opt = {
    to: argv.to || to,
    from: argv.from
  }
  if (Fs.existsSync(HIST_FILE)) {
    HISTORY = Jsonfile.readFileSync(HIST_FILE) || [];
    if (HISTORY.length) {
      opt = HISTORY.reverse()[0];
      if (opt.to && !opt.from) {
        opt.from = opt.to;
      }
    }
  }
  if (!opt.from) {
    usage(to, 1);
  }
  OPTIONS = opt;
  return `/me/bill?date.from=${opt.from}&date.to=${opt.to}`;
}

function getPrice(data){
  let price = '';
  if(data && data.priceWithoutTax){
    price = '[' + data.priceWithoutTax.text.padStart(12, " ") + ']';
  }
  return price;
}

// Format number as currency (European format)
function formatCurrency(value) {
  return value.toLocaleString('fr-FR', { minimumFractionDigits: 2, maximumFractionDigits: 2 });
}

// Generate markdown summary
function generateMarkdownSummary(billsData, options) {
  const lines = [];
  const totalHT = billsData.reduce((sum, b) => sum + (b.priceWithoutTax?.value || 0), 0);
  const totalTTC = billsData.reduce((sum, b) => sum + (b.priceWithTax?.value || 0), 0);

  lines.push(`# Récapitulatif Factures OVH`);
  lines.push(``);
  lines.push(`**Période :** ${options.from} au ${options.to}`);
  lines.push(`**Nombre de factures :** ${billsData.length}`);
  lines.push(``);
  lines.push(`## Résumé`);
  lines.push(``);
  lines.push(`| Métrique | Valeur |`);
  lines.push(`|----------|-------:|`);
  lines.push(`| Total HT | ${formatCurrency(totalHT)} € |`);
  lines.push(`| Total TTC | ${formatCurrency(totalTTC)} € |`);
  lines.push(``);
  lines.push(`## Liste des factures`);
  lines.push(``);
  lines.push(`| Facture | Date | Montant HT (€) | Montant TTC (€) |`);
  lines.push(`|---------|------|---------------:|----------------:|`);

  for (const bill of billsData) {
    const date = bill.date ? bill.date.split('T')[0] : '';
    const ht = bill.priceWithoutTax?.value || 0;
    const ttc = bill.priceWithTax?.value || 0;
    lines.push(`| ${bill.billId} | ${date} | ${formatCurrency(ht)} | ${formatCurrency(ttc)} |`);
  }

  lines.push(``);
  lines.push(`| **TOTAL** | | **${formatCurrency(totalHT)}** | **${formatCurrency(totalTTC)}** |`);
  lines.push(``);
  lines.push(`---`);
  lines.push(`*Généré le ${new Date().toISOString().split('T')[0]} par ovh-bill*`);

  return lines.join('\n');
}
/**
 * 
 * @param {*} api 
 * @returns 
 */
function getBill(bill) {
  const a = new Promise(async function (resolve, reject) {
    let url = `/me/bill/${bill}`;
    let data = await fetch(url);
    let fileUrl = data.pdfUrl;
    let target = Path.resolve(OUTPUT, `${bill}.pdf`);
    if (argv.format == 'html') {
      fileUrl = data.url;
      target = Path.resolve(OUTPUT, `${bill}.html`);
    }

    var localStream = Fs.createWriteStream(target);

    console.log(`Saving bill ${data.billId} ${getPrice(data)} into ${target}`);
    if (argv.verbose) {
      console.log("Date".padStart(20, '.'), data.date);
      for (let k in data) {
        if (/Id$|Tax$/.test(k)) {
          console.log(k.padStart(20, '.'), data[k]);
        }
      }
    }
    if (argv.json) {
      let json = { ...data };
      delete json.url;
      delete json.pdfUrl;
      let jfile = Path.resolve(OUTPUT, `${bill}.json`);
      Jsonfile.writeFileSync(jfile, json);
    }
    const req = https.request(fileUrl, res => {

      res.on('data', chunk => {
        localStream.write(chunk);
      })
      res.on('end', () => {
        resolve(target);
        localStream.end();
      })
    });

    req.on('error', (err) => {
      console.error("Failed to download", url);
      reject(err)
    });
    req.end()
  })
  return a;
}


/**
 * 
 * @returns 
 */
function fetch(url) {
  const a = new Promise(function (resolve, reject) {
    ovh.requestPromised('GET', url)
      .then(function (response) {
        resolve(response)
      })
      .catch(function (err) {
        console.log("Failed to fetch", url);
        if (/^\[date\.from\]/.test(err.message)) {
          console.error(`Start of period date ${OPTIONS.from} is invalid`);
        }else if (/^\[date\.to\]/.test(err.message)){
          console.error(`End of period date ${OPTIONS.to} is invalid`);
        }else if(err.message){
          if(err) console.error("OVH Server rejected:", err.message);
        }
        exit(1);
      });
  })
  return a;
}

function saveHistory(){
  let h = [];
  if(typeof(HISTORY.push) === "function"){
    h = HISTORY.push(OPTIONS);
  }
  Jsonfile.writeFileSync(HIST_FILE, h);
}

/**
 * Execute async functions with concurrency limit
 * @param {Array} items - Items to process
 * @param {Function} asyncFn - Async function to apply to each item
 * @param {number} concurrency - Max concurrent executions
 * @returns {Promise<Array>} - Results array
 */
async function parallelWithLimit(items, asyncFn, concurrency) {
  const results = [];
  const executing = new Set();

  for (const [index, item] of items.entries()) {
    const promise = Promise.resolve().then(() => asyncFn(item, index));
    results.push(promise);
    executing.add(promise);

    const cleanup = () => executing.delete(promise);
    promise.then(cleanup, cleanup);

    if (executing.size >= concurrency) {
      await Promise.race(executing);
    }
  }

  return Promise.all(results);
}

let cred = null;
let filenam = Path.resolve(APP_DATA, 'credentials.json');
try {
  if (argv.credentials) filenam = argv.credentials;
  cred = Jsonfile.readFileSync(filenam);
} catch (e) {
  console.error(`Could read credentials from file ${filenam}`);
  console.error(`Please be sure it exists and is a valid JSON file`);
  console.error(`type npm index.js --help to get some tips`);
  console.log("Visit https://github.com/somanos/ovh-bill#readme to learn more");
  exit(1);
}

if (!cred || !cred.appKey || !cred.appSecret || !cred.consumerKey) {
  tip();
}

const ovh = require('ovh')(cred);
let billsUrls = getBillsUrl();

let title = `| ... Getting bills for the period ${OPTIONS.from} - ${OPTIONS.to} ... |`;
console.log("".padStart(title.length, '-'));
console.log(title);
console.log("".padStart(title.length, '-'));


fetch(billsUrls).then(async (bills) => {
  //console.log("BILLS", bills);
  if (argv.output) {
    OUTPUT = argv.output;
  }

  if(!bills || !bills.length){
    console.log(`No bill found for the period ${OPTIONS.from} - ${OPTIONS.to}`);
    exit(0);
  }

  // If --summary flag is used, generate markdown summary only
  if (argv.summary) {
    console.error(`Fetching ${bills.length} bills metadata...`);
    const billsData = [];
    for (var bill of bills) {
      let url = `/me/bill/${bill}`;
      let data = await fetch(url);
      billsData.push(data);
    }
    // Sort by date
    billsData.sort((a, b) => new Date(a.date) - new Date(b.date));
    console.log(generateMarkdownSummary(billsData, OPTIONS));
    exit(0);
  }

  console.log(`Saving ${bills.length} bills into ${OUTPUT} (${CONCURRENT_DOWNLOADS} concurrent downloads)`);

  // Download bills in parallel with concurrency limit
  let completed = 0;
  const startTime = Date.now();

  await parallelWithLimit(bills, async (bill) => {
    await getBill(bill);
    completed++;
    // Progress indicator
    process.stdout.write(`\rProgress: ${completed}/${bills.length} bills downloaded`);
  }, CONCURRENT_DOWNLOADS);

  const elapsed = ((Date.now() - startTime) / 1000).toFixed(1);
  console.log(`\nCompleted in ${elapsed}s`);
})

